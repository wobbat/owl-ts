# Owl Package Manager - Codebase Refactoring Plan

## Current Issues Identified
1. **Code Duplication**: Command parsing logic repeated in commands.ts
2. **Large Files**: config.ts (500+ lines) handles multiple responsibilities
3. **Tight Coupling**: Handlers directly import many modules
4. **Inconsistent Patterns**: Mixed async/sync patterns, scattered utilities
5. **Missing Abstractions**: No clear interfaces for package managers

## Refactoring Plan

### Phase 1: Configuration Module Refactoring (High Priority)
**Goal**: Split config.ts into focused, single-responsibility modules

**New Structure**:
```
src/config/
├── index.ts              # Main exports
├── parser.ts             # Configuration parsing logic
├── loader.ts             # File loading and merging logic
├── validator.ts          # Configuration validation
├── types.ts              # Config-specific types
└── errors.ts             # Config-specific errors
```

**Tasks**:
- Extract OwlConfigEntry and related types to types.ts
- Move parseOwlConfig function to parser.ts
- Move loadConfigForHost function to loader.ts
- Create validator.ts for directive validation
- Create custom error classes in errors.ts

### Phase 2: Command Parser Factory (High Priority)
**Goal**: Eliminate duplication in command parsing logic

**New Structure**:
```
src/commands/
├── index.ts
├── parser-factory.ts
└── parsers/
    ├── base-parser.ts
    ├── search-parser.ts
    ├── add-parser.ts
    └── install-parser.ts
```

**Tasks**:
- Create CommandParserFactory class
- Extract command-specific parsing logic into separate parser classes
- Implement common interface for all parsers
- Update main.ts to use new factory

### Phase 3: Error Handling Standardization (Medium Priority)
**Goal**: Create consistent error handling patterns

**New Structure**:
```
src/errors/
├── index.ts
├── command-errors.ts
├── config-errors.ts
├── package-errors.ts
└── validation-errors.ts
```

**Tasks**:
- Create base OwlError class with code and category properties
- Implement specific error classes for different domains
- Update all handlers to use new error classes
- Create error handling utilities

### Phase 4: Package Manager Abstraction (Medium Priority)
**Goal**: Create interfaces for better testability and extensibility

**New Structure**:
```
src/package-managers/
├── index.ts
├── interfaces.ts
├── pacman-manager.ts
├── aur-manager.ts
└── composite-manager.ts
```

**Tasks**:
- Define IPackageManager interface
- Create PackageManagerStrategy pattern
- Refactor existing managers to implement interface
- Create composite manager for combining multiple sources

### Phase 5: Utils Reorganization (Medium Priority)
**Goal**: Better organization and consistent naming

**New Structure**:
```
src/utils/
├── index.ts
├── fs/
│   ├── index.ts
│   ├── paths.ts
│   └── directories.ts
├── async/
│   ├── index.ts
│   └── operations.ts
├── validation/
│   ├── index.ts
│   └── validators.ts
└── formatting/
    ├── index.ts
    └── display.ts
```

**Tasks**:
- Move existing utils into appropriate subdirectories
- Create consistent naming conventions
- Update all imports throughout codebase
- Add index files for clean exports

### Phase 6: Handler Base Classes (Medium Priority)
**Goal**: Extract common handler patterns

**New Structure**:
```
src/handlers/
├── base/
│   ├── command-handler.ts
│   └── async-handler.ts
├── commands/
│   ├── apply.ts
│   ├── search.ts
│   └── add.ts
└── processors/
    ├── package-processor.ts
    ├── config-processor.ts
    └── setup-processor.ts
```

**Tasks**:
- Create base handler classes with common functionality
- Extract processor logic into separate modules
- Update existing handlers to extend base classes
- Implement consistent error handling in base classes

### Phase 7: Dependency Injection (Lower Priority)
**Goal**: Improve testability and modularity

**New Structure**:
```
src/di/
├── container.ts
├── providers.ts
└── tokens.ts
```

**Tasks**:
- Implement dependency injection container
- Create provider classes for major dependencies
- Update main application to use DI container
- Add support for different environments/configurations

## Implementation Order
1. Start with Phase 1 (Configuration) - highest impact
2. Phase 2 (Command Parser) - eliminates duplication
3. Phase 3 (Error Handling) - improves consistency
4. Phase 4 (Package Managers) - improves testability
5. Phase 5 (Utils) - organizational improvement
6. Phase 6 (Handlers) - reduces code duplication
7. Phase 7 (DI) - advanced improvement for testing

## Benefits
- Reduced code duplication
- Better separation of concerns
- Improved testability
- Enhanced maintainability
- Easier extension for new features